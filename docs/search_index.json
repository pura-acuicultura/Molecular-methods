[["index.html", "Analysis of molecular data from fisheries and aquaculture Chapter 1 Introduction", " Analysis of molecular data from fisheries and aquaculture PURA acuicultura 2021-01-14 Chapter 1 Introduction It has been nearly 50 years since researchers first applied protein allozymes to the differentiation of fish stocks. Since that time, molecular biology has become an integral tool within both fisheries and aquaculture. A running list of molecular biology applications with aquaculture fisheries with emphasis on analysis is maintained here. Chapters include: Introduction to molecular data analysis in fisheries and aquaculture Differentiation of fish stocks using principle component analysis Pedigree, kinship and G-matrices Parentage assignment Linkage mapping Association mapping Genome-wide association studies (GWAS) Haplotype estimation (phasing) Imputation "],["differentiation-of-populations-using-pca.html", "Chapter 2 Differentiation of populations using PCA 2.1 Introduction 2.2 Background on the fish populations 2.3 SNP results 2.4 PCA analysis 2.5 Assessment of the principle components 2.6 PCA graphical analysis 2.7 Identify significant SNP", " Chapter 2 Differentiation of populations using PCA 2.1 Introduction Principle component analysis (PCA) is one of several methods for differentiating populations through molecular markers. At its most basic level it is a rapid an easy analysis to perform. Here, individuals from two fish populations are assessed using a low density, single nucleotide polymorphism (SNP) panel. PCA is explored in the context of developing methods for classifying individuals based only on molecular analysis. library(AlphaSimR) library(tidyverse) library(knitr) 2.2 Background on the fish populations A population of haplotypes is first made From the haplotypes, two populations are formed, A and B The populations are managed at two different hatcheries Hatchery A maintains a large effective population size throughout 10 generations Hatchery B, a much smaller effective population size also for 10 generations Inbreeding and genetic drift increase the homozygocity of population B We will use principle component analysis to try and differentiate the populations at each generation pop_haplos &lt;- quickHaplo(nInd = 10, # number of individuals nChr = 3, # number of chromosomes segSites = 1000, # number of segregation sites genLen = 1, # genetic length of chromosomes ploidy = 2L, # ploidy level of organism inbred = TRUE) # are founders inbred? SP = SimParam$new(pop_haplos) # create a variable for new simulation parameters SP$addTraitA(nQtlPerChr = 100, # number of QTL for trait mean = 500, # mean genetic value of the trait var = 100, # variance of trait corA = NULL, # matrix of correlations between additive effects gamma = FALSE, # to use a gamma distribution in place of a normal distribution shape = 1, # shape parameter for gamma distribution only force = FALSE) # keep false until this is understood! SP$setVarE(h2 = 0.3, # vector of narrow sense heritability H2 = NULL, # vector of broad sense heritability varE = NULL) # vector of error variances SP$addSnpChip(nSnpPerChr = 32, # number of SNPs per chromosome minSnpFreq = NULL, # minimum allowable frequency for SNP loci refPop = NULL) # reference population for calculating SNP frequency gen &lt;- 10 # specify the number of generations for which selection will be carried out #__ 3.1 Develop population A ##### pop_A &lt;- newPop(rawPop = pop_haplos, # object of MapPop-class mother = NULL, # optional id for mothers father = NULL, # optional id for fathers origM = NULL, # optional alternative id for mothers origF = NULL, # optional alternative id for fathers isDH = FALSE, # indicate if double haploids and/or inbred simParam = SP) # SimParam objects POP_A &lt;- vector(length = gen, mode = &quot;list&quot;) # create a vector of lists to store the population for each generation POP_A[[1]] &lt;- pop_A # add the founder population to the vector of lists for (i in 2:gen) { POP_A[[i]] &lt;- randCross(pop = POP_A[[i - 1]], nCrosses = 10, nProgeny = 1, balance = TRUE, parents = NULL, simParam = SP)} 2.3 SNP results SNP results are returned as a data matrix of m rows and n columns. Each row is an individual fish and each column is a different SNP. 10 individuals from each hatchery were assessed so m = 20 observations exist. The low density SNP panel consists of 96 SNP so n = 96 variables exist. For each individual, each SNP is assessed as 0, 1, or 2 where 0 equates to homzygous recessive, 1 to heterozygous, and 2 to homozygous dominant. It is important to note that the terms recessive and dominant do not necessarily correspond with the genetic definitions of these terms. In the case of an SNP panel, they correspond with the allele-by-reporter dye combination chosen during assay development. The first few rows and columns of the SNP results are shown. Note that the matrix contains only data and that fish IDs and SNP IDs exist only as row and column names. This is clear evidence that PCA analysis incorporates no prior knowledge of population origin and relies completely on genotypic data. c_gen &lt;- 10 # specify the generation at which PCA will be performed snp_A &lt;- pullSnpGeno(pop = POP_A[[c_gen]], # Pop-class object snpChip = 1, # which chip to use chr = NULL, # chromosome number, NULL = all simParam = SP) # SimParam object snp_B &lt;- pullSnpGeno(pop = POP_B[[c_gen]], # Pop-class object snpChip = 1, # which chip to use chr = NULL, # chromosome number, NULL = all simParam = SP) # SimParam object snp_pops &lt;- rbind(snp_A, snp_B) kable(snp_pops[1:20, 1:12]) SNP_1 SNP_2 SNP_3 SNP_4 SNP_5 SNP_6 SNP_7 SNP_8 SNP_9 SNP_10 SNP_11 SNP_12 91 0 0 2 2 2 1 1 1 1 1 1 1 92 1 0 2 2 2 2 2 2 2 0 0 0 93 0 1 2 1 2 1 1 1 2 0 1 0 94 0 1 2 1 2 2 2 2 1 0 1 0 95 0 1 2 1 2 2 2 2 1 0 1 0 96 0 2 2 0 2 1 1 1 0 1 2 1 97 1 2 2 1 2 1 1 1 2 0 1 0 98 0 2 2 0 2 2 2 2 2 0 0 0 99 1 1 2 1 2 1 1 1 2 0 1 0 100 1 1 2 1 2 1 1 1 1 1 1 1 191 1 0 1 0 1 2 2 1 2 0 1 1 192 2 0 0 0 2 2 2 1 2 0 1 1 193 2 0 0 0 2 2 2 2 2 0 0 0 194 1 0 1 0 1 2 2 1 2 0 1 1 195 2 1 2 0 0 2 2 0 2 0 2 2 196 1 1 2 1 0 2 2 0 2 0 1 0 197 1 1 2 1 0 1 1 1 2 0 1 1 198 2 1 1 1 1 1 1 2 2 0 0 0 199 2 1 1 1 0 1 2 1 2 0 1 1 200 1 0 2 0 0 2 2 0 2 0 2 2 2.4 PCA analysis The fish x SNP data matrix can be analyzed directly using the function prcomp(). When performing PCA with numeric variables such as gene expression it is common to normalize them by adding scale = TRUE. Despite being in numerical form, the measures of genotype from the SNP are really categorical. Nonetheless, for the purpose of PCA they exist as integers already scaled from 0 to 2. For this reason, the default scale = FALSE is used. The function prcomp() produces a list of 5 output categories, of which $x and $sdev are used in the downstream analysis here. $x is a data matrix of m rows and n columns. Rows correspond to the number of SNP such that m = 96 observations exist. Columns correspond to principle components which although derived through analysis also corresponds to the number of SNP such that n = 96 variables. pca &lt;- prcomp(snp_pops) pca.data &lt;- data.frame(fish_ID = rownames(pca$x), # vector of fish IDs hatchery = c(rep(&quot;A&quot;, gen),(rep(&quot;B&quot;, gen))), X = pca$x[,1], # vector of PC1 in order of fish IDs Y = pca$x[,2]) # vector of PC2 in order of fish IDs 2.5 Assessment of the principle components The following code compiles a data frame of principle component effects. A vector of principle component IDs is first made as p_comp. The number of principle components is always equal to the number of subjects, 20 fish in our case. The vector was made simply as 1 to subject number using number of columns from the pca$x matrix. Although column number was used because each column represents one principle component in pca$x, row number which equates to subjects could just as easily be used. After the principle component IDs were called, the standard deviation of the principle components was called as pca$sd. Squaring the standard deviations resulted in pca_var, the variance of the principle components. Due to the additive nature of variance, the percent of the total variance could then be calculated for each of the principle components. Finally, the individual vectors were assembled into a data frame and the first few lines shown. p_comp &lt;- 1:dim(pca$x)[2] # create a vector pf principle component IDs pca_sd &lt;- pca$sdev # call the standard deviation from the PCA results pca_var &lt;- pca_sd^2 # calculate the variance of the principle components pca_var_per &lt;- round(pca_var / sum(pca_var) * 100, 1) # calculate the percent variance of the total variance for each principle component df_p_comp &lt;- data.frame(p_comp, pca_sd, pca_var, pca_var_per) kable(head(df_p_comp)) p_comp pca_sd pca_var pca_var_per 1 4.015707 16.125903 41.9 2 2.013617 4.054653 10.5 3 1.812827 3.286343 8.5 4 1.544549 2.385633 6.2 5 1.396697 1.950764 5.1 6 1.330403 1.769972 4.6 It is a good idea to look at all principle components together in a figure. This can easily be performed through a scree plot. Scree plots are generally presented as line or bar graphs in the form of percent variation as a function of principle component. As per the analysis, the principle components on the x-axis are ordered from the most-to-least influential. df_p_comp %&gt;% ggplot(aes(x = p_comp, y = pca_var_per)) + geom_point(stat = &#39;identity&#39;, color = &quot;blue&quot;, size = 2) + geom_line(linetype = &quot;dotted&quot;, color = &quot;blue&quot;, size = 1) + theme_bw() + xlab(&quot;principle component&quot;) + ylab(&quot;effect size (percent)&quot;) 2.6 PCA graphical analysis The primary goal of PCA is to reduce the number of independent variables (SNP in our case) needed to differentiate between dependent factors (individuals and their populations in our case) In the receding figure we see that by generation 10 there is a pretty clear separation of the two hatchery populations. Our next task is to understand the relative effects of the principle components, and then the relative effects of the SNPs within the most influential principle components. In our example we might find that only a few SNP, rather than a low density chip, are all that is needed to differentiate our populations. It would also be a first step in a functional characterization of the genetic differences between the two populations. pca.data %&gt;% ggplot(aes(x = X, y = Y, label = fish_ID)) + geom_text(size = 3, color = &quot;black&quot;) + geom_point(aes(color = hatchery), size = 8, alpha = 0.5) + xlab(paste(&quot;PC1 - &quot;, pca_var_per[1], &quot;%&quot;, sep=&quot;&quot;)) + ylab(paste(&quot;PC2 - &quot;, pca_var_per[2], &quot;%&quot;, sep=&quot;&quot;)) + scale_color_manual(values = c(&quot;A&quot; = &quot;blue&quot;, &quot;B&quot; = &quot;grey&quot;)) + theme_bw() + ggtitle(paste(&quot;generation&quot;, c_gen, sep = &quot; &quot;)) 2.7 Identify significant SNP "],["an-introduction-to-linkage-mapping.html", "Chapter 3 An introduction to linkage mapping 3.1 Creating the parental haplotypes 3.2 Set simulation parameters and simulate parent population 3.3 Cross parents and simulate offspring population 3.4 Pull genotype data for parents and offspring 3.5 Pairwise comparison of parent/offsping genotypes 3.6 Understanding the pairwise comparisons 3.7 developing the linkage map", " Chapter 3 An introduction to linkage mapping Here we create a simple simulator to demonstrate the underlying principles of linkage mapping. Simulations are conducted using AlphaSimR. Analysis is carried out using Tidyverse tools such as dplyr and ggplot. The simulator is constructed with three independent variables, chromosome number, segregation site number, and offspring number as a foundation for understanding how these variables contribute to the precision and accuracy of the linkage maps themselves. library(AlphaSimR) library(tidyverse) library(knitr) n_chr &lt;- 1 # variable 1, number of chromosomes in genome n_seg &lt;- 10 # variable 2, number of segregation sites per chromosome n_off &lt;- 100 # variable 3. number of offspring per parental cross The selection of parents is the most critical aspect of successful linkage mapping. Parents are not selected based on specific traits or physical health but on characteristics of their genomes that facilitate mapping. We will start with the most textbook of approaches, crossing of a completely heterozygous individual (10) with a completely homozygous recessive individual (00). under such circumstances, offspring are expected to be 50% heterozygous (10) and 50% homozygous recessive (00). As such, any deviation from these percentages provides evidence for linkage between segregation sites, and the data needed to create the linkage map itself. 3.1 Creating the parental haplotypes Rather than using quickHaplo(), custom haplotypes will be defined using the newMapPop() function. As arguments, newMapPop() requires a genetic map and a list of corresponding haplotypes. The following code first creates the genetic map. The seq() function is used to create a numerical list from 0 to 1. By setting length.out equal to the n_seg, a list of equally sized segregation sites is created. It should be noted that defining the genetic map from 0 to 1 results in a chromosome length of 1 Morgan (NB: 100 cM). Defining the haplotypes genMap &lt;- list(seq(0, 1, length.out = n_seg)) # list of segregation sites round(unlist(genMap[1]),2) # show the list of segregation sites ## [1] 0.00 0.11 0.22 0.33 0.44 0.56 0.67 0.78 0.89 1.00 chr1 &lt;- c(rep(1, n_seg), # haplotype 1 of heterozygote parent rep(0, n_seg), # haplotype 2 of heterozygote parent rep(0, n_seg), # haplotypes 1 of homozygous parent rep(0, n_seg)) # haplotypes 2 of homozygous parent chr1 &lt;- matrix(chr1, nrow = 4, ncol = n_seg, byrow = TRUE) # coerce into a matrix chr1 # show the matrix of haplotypes ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 1 1 1 1 1 1 1 1 1 ## [2,] 0 0 0 0 0 0 0 0 0 0 ## [3,] 0 0 0 0 0 0 0 0 0 0 ## [4,] 0 0 0 0 0 0 0 0 0 0 pop_haplos &lt;- newMapPop(genMap = genMap, haplotypes = list(chr1)) 3.2 Set simulation parameters and simulate parent population SP = SimParam$new(pop_haplos) # create a variable for new simulation parameters SP$setSexes(&quot;yes_sys&quot;) # set sexes systematically pop_0 &lt;- newPop(rawPop = pop_haplos, # object of MapPop-class simParam = SP) # SimParam objects 3.3 Cross parents and simulate offspring population crossPlan &lt;- matrix(c(1, 2), nrow = 1, ncol = 2) # develop a simple cross plan pop_1 &lt;- makeCross(pop = pop_0, # Pop-class object crossPlan = crossPlan, # two column matrix indicating female/male cross made nProgeny = n_off, # number of progeny per cross simParam = SP) # simParam object 3.4 Pull genotype data for parents and offspring df_P &lt;- pullSegSiteGeno(pop = pop_0, # Pop-class object chr = 1, # chromosome number, NULL = all simParam = SP) # SimParam object df_P &lt;- as.data.frame(df_P) df_O &lt;- pullSegSiteGeno(pop = pop_1, # Pop-class object chr = 1, # chromosome number, NULL = all simParam = SP) # SimParam object df_O &lt;- as.data.frame(df_O) df_P[, 1:10] ## SITE_1 SITE_2 SITE_3 SITE_4 SITE_5 SITE_6 SITE_7 SITE_8 SITE_9 SITE_10 ## 1 1 1 1 1 1 1 1 1 1 1 ## 2 0 0 0 0 0 0 0 0 0 0 df_O[1:10, 1:10] ## SITE_1 SITE_2 SITE_3 SITE_4 SITE_5 SITE_6 SITE_7 SITE_8 SITE_9 SITE_10 ## 3 1 1 1 1 1 1 1 1 1 0 ## 4 0 0 1 1 1 1 1 1 1 1 ## 5 0 0 0 0 1 0 0 0 0 0 ## 6 1 0 0 0 0 0 0 0 0 0 ## 7 1 1 1 1 1 1 1 1 1 1 ## 8 0 0 0 1 1 1 1 0 0 0 ## 9 0 0 0 0 1 1 0 0 0 0 ## 10 1 1 0 0 0 0 0 0 0 0 ## 11 0 0 0 0 0 0 0 0 0 0 ## 12 0 0 0 0 0 0 0 0 0 1 3.5 Pairwise comparison of parent/offsping genotypes Recombination is assessed as the percentage of crossover events occurring between two genes, or segregation sites in our case. If physical map data exists, one might investigate recombination across a chromosome by performing pairwise assessments of each segregation site against its nearest downstream neighbor. Under such a scenario, a sum of crossover events provides the total length of the chromosome in units of genetic linkage. When physical map data does not exist, as was the case for all historic linkage mapping, the assessment is more complex. We will employ what is perhaps the most straightforward approach, performing pairwise assessments of all possible segregation site combinations. As can be imagined, this approach can become unwieldy and computationally inefficient as the number of segregation sites (NB: molecular markers) increases. Nonetheless, it is a good method for understanding the basic principles underlying linkage mapping. We start the assessment by making a data frame of all possible pairwise combination. The data frame called pair_plan in the following code consists of two columns, ss1 and ss2. In this case, ss stands for segregation site such that each row of the data frame expresses a pair of segregation sites for assessment. The code was written to create the data frame based on the number of segregation sites. Using 5 segregation sites as an example, the first two lines results in a vector of 1,1,1,1,2,2,2,3,3,4 while the third and fourth lines result in a vector of 2,3,4,5,3,4,5,4,5,5. As such, the resulting data frame contains all unique pairs and excludes the comparison of segregation sites with themselves. While the code get s the job done there are certainly a multitude of other more efficient ways to do the same thing. a &lt;- 1:(n_seg-1) ss1 &lt;- rep(a, (n_seg - a)) foo &lt;- function(b){c(1:(n_seg))[b:n_seg]} ss2 &lt;- unlist(lapply(2:(n_seg), FUN = foo)) pair_plan &lt;- data.frame(ss1, ss2) pair_plan ## ss1 ss2 ## 1 1 2 ## 2 1 3 ## 3 1 4 ## 4 1 5 ## 5 1 6 ## 6 1 7 ## 7 1 8 ## 8 1 9 ## 9 1 10 ## 10 2 3 ## 11 2 4 ## 12 2 5 ## 13 2 6 ## 14 2 7 ## 15 2 8 ## 16 2 9 ## 17 2 10 ## 18 3 4 ## 19 3 5 ## 20 3 6 ## 21 3 7 ## 22 3 8 ## 23 3 9 ## 24 3 10 ## 25 4 5 ## 26 4 6 ## 27 4 7 ## 28 4 8 ## 29 4 9 ## 30 4 10 ## 31 5 6 ## 32 5 7 ## 33 5 8 ## 34 5 9 ## 35 5 10 ## 36 6 7 ## 37 6 8 ## 38 6 9 ## 39 6 10 ## 40 7 8 ## 41 7 9 ## 42 7 10 ## 43 8 9 ## 44 8 10 ## 45 9 10 pws &lt;- 1:dim(pair_plan)[1] rgf &lt;- function(pws){ ssA &lt;- pair_plan[pws, 1] ssB &lt;- pair_plan[pws, 2] p1 &lt;- paste(df_P[1,ssA], df_P[2,ssB], sep = &quot;&quot;) p2 &lt;- paste(df_P[2,ssA], df_P[1,ssB], sep = &quot;&quot;) dplyr::select(df_O, df_O[,ssA], df_O[,ssB]) %&gt;% mutate(pair = paste(df_O[,ssA], df_O[,ssB], sep = &quot;&quot;)) %&gt;% mutate(recomb = ifelse(pair %in% c(p1, p2), 1, 0)) %&gt;% summarize(sum = sum(recomb)/length(pop_1@id)) } reco &lt;- unlist(lapply(pws, FUN = rgf)) 3.6 Understanding the pairwise comparisons # actual linkage distances between segregation sites pair_plan %&gt;% group_by(ss1) %&gt;% mutate(min = min(reco)) %&gt;% ungroup() %&gt;% filter(reco == min) ## # A tibble: 1 x 3 ## ss1 ss2 min ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 8 9 0.07 # verify the order of the segregation sites pair_plan %&gt;% filter(ss1 == 1) ## ss1 ss2 ## 1 1 2 ## 2 1 3 ## 3 1 4 ## 4 1 5 ## 5 1 6 ## 6 1 7 ## 7 1 8 ## 8 1 9 ## 9 1 10 3.7 developing the linkage map "]]
